# TotalSpineSeg 网络模型详细分析

## 目录

1. [模型架构概述](#模型架构概述)
2. [nnU-Net基础架构](#nnu-net基础架构)
3. [Step 1模型（Dataset101）详细分析](#step-1模型dataset101详细分析)
4. [Step 2模型（Dataset102）详细分析](#step-2模型dataset102详细分析)
5. [网络层次结构](#网络层次结构)
6. [训练配置](#训练配置)
7. [推理过程](#推理过程)
8. [后处理算法](#后处理算法)

---

## 模型架构概述

TotalSpineSeg采用**两阶段混合架构**，结合了nnU-Net深度学习模型和迭代后处理算法：

```
输入MRI图像
    ↓
[Step 1: Dataset101] → 语义分割 + 关键标志点识别
    ↓
迭代算法处理 → 提取奇数椎间盘
    ↓
[Step 2: Dataset102] → 双通道输入（MRI + 奇数椎间盘）
    ↓
迭代算法处理 → 最终精确标记
    ↓
输出：完整的分割和标记结果
```

### 核心特点

- **基础架构**: nnU-Net v2（基于PyTorch）
- **训练器**: `nnUNetTrainer_DASegOrd0_NoMirroring`
- **配置**: `3d_fullres`（3D全分辨率）
- **计划文件**: `nnUNetPlans_small`（小补丁大小配置）
- **交叉验证**: 5折交叉验证（folds: 0, 1, 2, 3, 4）

---

## nnU-Net基础架构

### nnU-Net简介

nnU-Net（no-new-Net）是一个自配置的医学图像分割框架，能够根据数据集特性自动调整网络架构和训练参数。

### 核心组件

#### 1. U-Net架构变体

nnU-Net使用3D U-Net架构，包含以下关键组件：

```
编码器（Encoder/下采样路径）:
├── 输入层
├── 卷积块（Conv Block）
├── 下采样层（Downsampling）
└── 重复4-5次

瓶颈层（Bottleneck）:
└── 最深层特征表示

解码器（Decoder/上采样路径）:
├── 上采样层（Upsampling）
├── 跳跃连接（Skip Connections）
├── 卷积块（Conv Block）
└── 重复4-5次

输出层:
└── 分类头（Classification Head）
```

#### 2. 3D U-Net详细结构

**编码器路径（收缩路径）**:
- **目的**: 提取多尺度特征，逐步增加感受野
- **操作**: 3D卷积 → 批量归一化 → ReLU激活 → 最大池化
- **深度**: 通常5-6层，每层特征图尺寸减半

**解码器路径（扩张路径）**:
- **目的**: 恢复空间分辨率，结合细节信息
- **操作**: 转置卷积（或双线性插值）→ 拼接跳跃连接 → 3D卷积
- **深度**: 与编码器对称

**跳跃连接**:
- **目的**: 保留细节信息，解决梯度消失问题
- **方式**: 将编码器对应层的特征图直接连接到解码器

### nnU-Net自动配置特性

nnU-Net会根据数据集自动确定：

1. **网络深度**: 根据图像尺寸自动调整
2. **初始特征数**: 根据数据集大小和类别数调整
3. **补丁大小**: 根据GPU内存自动优化
4. **批量大小**: 根据可用内存调整
5. **数据增强策略**: 自动选择适合的增强方法

---

## Step 1模型（Dataset101）详细分析

### 模型配置

- **数据集ID**: Dataset101_TotalSpineSeg_step1
- **输入通道数**: 1（MRI图像）
- **输出类别数**: 9
- **配置**: `3d_fullres`
- **计划**: `nnUNetPlans_small`

### 输入输出规格

#### 输入
- **格式**: NIfTI格式（`.nii.gz`）
- **通道**: 单通道MRI图像
- **预处理**: 
  - 重采样到1×1×1mm各向同性分辨率
  - 重定向到LPI(-)方向
  - Z-score归一化

#### 输出类别（9类）

| 类别ID | 类别名称 | 说明 |
|:------|:--------|:-----|
| 0 | background | 背景 |
| 1 | disc (general) | 通用椎间盘（未标记） |
| 2 | disc_C2_C3 | C2-C3椎间盘（关键标志点） |
| 3 | disc_C7_T1 | C7-T1椎间盘（关键标志点） |
| 4 | disc_T12_L1 | T12-L1椎间盘（关键标志点） |
| 5 | disc_L5_S | L5-S椎间盘（关键标志点） |
| 6 | vertebrae (general) | 通用椎骨（未标记） |
| 7 | vertebrae_C1 | C1椎骨（关键标志点） |
| 8 | canal | 椎管 |
| 9 | cord | 脊髓 |

### 网络架构细节

#### 编码器（下采样路径）

```
输入: [B, 1, D, H, W]  # B=batch, D=depth, H=height, W=width

Level 0 (输入层):
├── Conv3D(1 → 32, kernel=3×3×3, padding=1)
├── InstanceNorm3D(32)
├── LeakyReLU(0.01)
├── Conv3D(32 → 32, kernel=3×3×3, padding=1)
├── InstanceNorm3D(32)
└── LeakyReLU(0.01)
输出: [B, 32, D, H, W]

Level 1:
├── MaxPool3D(kernel=2×2×2, stride=2)
├── Conv3D(32 → 64, kernel=3×3×3, padding=1)
├── InstanceNorm3D(64)
├── LeakyReLU(0.01)
├── Conv3D(64 → 64, kernel=3×3×3, padding=1)
├── InstanceNorm3D(64)
└── LeakyReLU(0.01)
输出: [B, 64, D/2, H/2, W/2]

Level 2:
├── MaxPool3D(kernel=2×2×2, stride=2)
├── Conv3D(64 → 128, kernel=3×3×3, padding=1)
├── InstanceNorm3D(128)
├── LeakyReLU(0.01)
├── Conv3D(128 → 128, kernel=3×3×3, padding=1)
├── InstanceNorm3D(128)
└── LeakyReLU(0.01)
输出: [B, 128, D/4, H/4, W/4]

Level 3:
├── MaxPool3D(kernel=2×2×2, stride=2)
├── Conv3D(128 → 256, kernel=3×3×3, padding=1)
├── InstanceNorm3D(256)
├── LeakyReLU(0.01)
├── Conv3D(256 → 256, kernel=3×3×3, padding=1)
├── InstanceNorm3D(256)
└── LeakyReLU(0.01)
输出: [B, 256, D/8, H/8, W/8]

Level 4 (最深层):
├── MaxPool3D(kernel=2×2×2, stride=2)
├── Conv3D(256 → 320, kernel=3×3×3, padding=1)
├── InstanceNorm3D(320)
├── LeakyReLU(0.01)
├── Conv3D(320 → 320, kernel=3×3×3, padding=1)
├── InstanceNorm3D(320)
└── LeakyReLU(0.01)
输出: [B, 320, D/16, H/16, W/16]
```

#### 解码器（上采样路径）

```
Level 4 → Level 3:
├── TransposeConv3D(320 → 256, kernel=2×2×2, stride=2)
├── Concatenate([上采样特征, Level 3编码器特征])
├── Conv3D(512 → 256, kernel=3×3×3, padding=1)  # 320+256=576 → 256
├── InstanceNorm3D(256)
├── LeakyReLU(0.01)
├── Conv3D(256 → 256, kernel=3×3×3, padding=1)
├── InstanceNorm3D(256)
└── LeakyReLU(0.01)
输出: [B, 256, D/8, H/8, W/8]

Level 3 → Level 2:
├── TransposeConv3D(256 → 128, kernel=2×2×2, stride=2)
├── Concatenate([上采样特征, Level 2编码器特征])
├── Conv3D(256 → 128, kernel=3×3×3, padding=1)
├── InstanceNorm3D(128)
├── LeakyReLU(0.01)
├── Conv3D(128 → 128, kernel=3×3×3, padding=1)
├── InstanceNorm3D(128)
└── LeakyReLU(0.01)
输出: [B, 128, D/4, H/4, W/4]

Level 2 → Level 1:
├── TransposeConv3D(128 → 64, kernel=2×2×2, stride=2)
├── Concatenate([上采样特征, Level 1编码器特征])
├── Conv3D(128 → 64, kernel=3×3×3, padding=1)
├── InstanceNorm3D(64)
├── LeakyReLU(0.01)
├── Conv3D(64 → 64, kernel=3×3×3, padding=1)
├── InstanceNorm3D(64)
└── LeakyReLU(0.01)
输出: [B, 64, D/2, H/2, W/2]

Level 1 → Level 0:
├── TransposeConv3D(64 → 32, kernel=2×2×2, stride=2)
├── Concatenate([上采样特征, Level 0编码器特征])
├── Conv3D(64 → 32, kernel=3×3×3, padding=1)
├── InstanceNorm3D(32)
├── LeakyReLU(0.01)
├── Conv3D(32 → 32, kernel=3×3×3, padding=1)
├── InstanceNorm3D(32)
└── LeakyReLU(0.01)
输出: [B, 32, D, H, W]
```

#### 输出层

```
├── Conv3D(32 → 9, kernel=1×1×1)  # 9个输出类别
└── Softmax (或直接输出logits)
输出: [B, 9, D, H, W]
```

### 训练器特性：nnUNetTrainer_DASegOrd0_NoMirroring

#### DASeg（Deep Attention Segmentation）

- **特点**: 使用深度注意力机制增强特征表示
- **优势**: 更好地关注重要区域，提高分割精度

#### Ord0（Order 0）

- **含义**: 使用0阶统计信息（均值）进行特征聚合
- **应用**: 在注意力机制中使用

#### NoMirroring

- **含义**: 训练时不使用镜像数据增强
- **原因**: 脊柱具有明确的方向性，镜像会破坏解剖结构的正确性
- **影响**: 减少数据增强，但保持解剖正确性

### 损失函数

nnU-Net通常使用以下损失函数的组合：

1. **Dice Loss**: 用于处理类别不平衡
   ```
   Dice_Loss = 1 - (2 * |X ∩ Y|) / (|X| + |Y|)
   ```

2. **Cross-Entropy Loss**: 标准分类损失
   ```
   CE_Loss = -Σ y_true * log(y_pred)
   ```

3. **组合损失**:
   ```
   Total_Loss = α * Dice_Loss + (1-α) * CE_Loss
   ```

### 后处理（Step 1）

Step 1的输出经过以下后处理：

1. **最大连通分量提取**: 保留最大的连通区域
2. **迭代标记算法**: 基于关键标志点（C2-C3, C7-T1, T12-L1, L5-S）标记所有椎间盘
3. **奇数椎间盘提取**: 提取奇数位置的椎间盘（C3-C4, C5-C6, T1-T2, T3-T4, ...）

---

## Step 2模型（Dataset102）详细分析

### 模型配置

- **数据集ID**: Dataset102_TotalSpineSeg_step2
- **输入通道数**: 2（MRI图像 + 奇数椎间盘）
- **输出类别数**: 11
- **配置**: `3d_fullres`
- **计划**: `nnUNetPlans_small`

### 输入输出规格

#### 输入（双通道）

- **通道0**: MRI图像（与Step 1相同）
- **通道1**: 从Step 1提取的奇数椎间盘分割（未归一化，作为辅助信息）

#### 输出类别（11类）

| 类别ID | 类别名称 | 说明 |
|:------|:--------|:-----|
| 0 | background | 背景 |
| 1 | disc (general) | 通用椎间盘 |
| 2 | disc_C2_C3 | C2-C3椎间盘（关键标志点） |
| 3 | disc_C7_T1 | C7-T1椎间盘（关键标志点） |
| 4 | disc_T12_L1 | T12-L1椎间盘（关键标志点） |
| 5 | disc_L5_S | L5-S椎间盘（关键标志点） |
| 6 | vertebrae (general) | 通用椎骨 |
| 7 | vertebrae_O (odd) | 奇数椎骨（C1, C3, C5, C7, T2, T4, ...） |
| 8 | vertebrae_E (even) | 偶数椎骨（C2, C4, C6, T1, T3, T5, ...） |
| 9 | sacrum | 骶骨（关键标志点） |
| 10 | canal | 椎管 |
| 11 | cord | 脊髓 |

### 网络架构

Step 2的网络架构与Step 1基本相同，但有以下关键差异：

#### 输入层差异

```
输入: [B, 2, D, H, W]  # 双通道输入

Level 0 (输入层):
├── Conv3D(2 → 32, kernel=3×3×3, padding=1)  # 注意：输入通道为2
├── InstanceNorm3D(32)
├── LeakyReLU(0.01)
├── Conv3D(32 → 32, kernel=3×3×3, padding=1)
├── InstanceNorm3D(32)
└── LeakyReLU(0.01)
输出: [B, 32, D, H, W]
```

#### 输出层差异

```
├── Conv3D(32 → 11, kernel=1×1×1)  # 11个输出类别
└── Softmax
输出: [B, 11, D, H, W]
```

### 双通道输入的优势

1. **上下文信息**: 奇数椎间盘提供空间上下文，帮助模型理解脊柱结构
2. **引导分割**: 辅助通道引导模型更准确地分割偶数椎骨和椎间盘
3. **减少歧义**: 通过已知的奇数位置，减少相邻椎骨/椎间盘的混淆

### 后处理（Step 2）

Step 2的输出经过以下后处理：

1. **最大连通分量提取**: 保留最大的连通区域
2. **迭代标记算法**: 
   - 基于关键标志点标记所有椎间盘
   - 基于关键标志点和奇数/偶数分类标记所有椎骨
3. **椎管填充**: 填充椎管标签，包括所有非脊髓的椎管区域

---

## 网络层次结构

### 完整网络层次图

```
输入图像 [B, C, D, H, W]
    │
    ├─┐
    │ │
    ▼ ▼
┌─────────────────────────────────────────┐
│         编码器路径（下采样）              │
├─────────────────────────────────────────┤
│ Level 0: Conv→Norm→ReLU→Conv→Norm→ReLU │
│          [B, 32, D, H, W]               │
│              ↓ MaxPool                  │
│ Level 1: Conv→Norm→ReLU→Conv→Norm→ReLU │
│          [B, 64, D/2, H/2, W/2]         │
│              ↓ MaxPool                  │
│ Level 2: Conv→Norm→ReLU→Conv→Norm→ReLU │
│          [B, 128, D/4, H/4, W/4]        │
│              ↓ MaxPool                  │
│ Level 3: Conv→Norm→ReLU→Conv→Norm→ReLU │
│          [B, 256, D/8, H/8, W/8]        │
│              ↓ MaxPool                  │
│ Level 4: Conv→Norm→ReLU→Conv→Norm→ReLU │
│          [B, 320, D/16, H/16, W/16]     │
└─────────────────────────────────────────┘
    │
    │ (瓶颈层)
    │
    ▼
┌─────────────────────────────────────────┐
│         解码器路径（上采样）              │
├─────────────────────────────────────────┤
│ Level 4: TransConv→Concat→Conv→Norm→ReLU│
│          [B, 256, D/8, H/8, W/8]         │
│              ↑ Skip Connection          │
│ Level 3: TransConv→Concat→Conv→Norm→ReLU│
│          [B, 128, D/4, H/4, W/4]         │
│              ↑ Skip Connection          │
│ Level 2: TransConv→Concat→Conv→Norm→ReLU│
│          [B, 64, D/2, H/2, W/2]          │
│              ↑ Skip Connection          │
│ Level 1: TransConv→Concat→Conv→Norm→ReLU│
│          [B, 32, D, H, W]                │
│              ↑ Skip Connection          │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│           输出层                         │
│          Conv1×1×1                      │
│          [B, N_classes, D, H, W]       │
└─────────────────────────────────────────┘
    │
    ▼
输出分割图 [B, N_classes, D, H, W]
```

### 关键参数

#### 卷积层参数

- **卷积核大小**: 3×3×3（标准3D卷积）
- **填充**: 1（保持空间尺寸）
- **步长**: 1（编码器/解码器中的标准卷积）

#### 下采样

- **方法**: 最大池化（MaxPooling3D）
- **核大小**: 2×2×2
- **步长**: 2
- **效果**: 空间尺寸减半，特征数增加

#### 上采样

- **方法**: 转置卷积（Transposed Convolution / Deconvolution）
- **核大小**: 2×2×2
- **步长**: 2
- **效果**: 空间尺寸加倍，特征数减少

#### 归一化

- **方法**: 实例归一化（Instance Normalization）
- **优势**: 对批次大小不敏感，适合医学图像

#### 激活函数

- **类型**: LeakyReLU
- **负斜率**: 0.01
- **优势**: 避免ReLU的"死亡神经元"问题

---

## 训练配置

### 训练参数

#### 基础配置

- **优化器**: Adam优化器
- **学习率**: 初始学习率由nnU-Net自动确定（通常约1e-3）
- **学习率调度**: 多项式衰减或余弦退火
- **批量大小**: 根据GPU内存自动调整（通常2-4）
- **训练轮数**: 1000 epochs（或早停）

#### 数据增强

由于使用`NoMirroring`训练器，数据增强策略包括：

1. **旋转**: 随机旋转（±15度）
2. **缩放**: 随机缩放（0.85-1.25倍）
3. **弹性变形**: 随机弹性变形
4. **灰度值增强**: 
   - 随机亮度调整
   - 随机对比度调整
   - 随机伽马校正
5. **高斯噪声**: 随机添加高斯噪声
6. **高斯模糊**: 随机应用高斯模糊

**不包含**:
- ❌ 镜像翻转（保持解剖方向正确性）

#### 交叉验证

- **折数**: 5折交叉验证
- **折ID**: 0, 1, 2, 3, 4
- **用途**: 模型集成（ensemble）提高鲁棒性

#### 补丁训练

- **策略**: 滑动窗口训练
- **补丁大小**: 由`nnUNetPlans_small`确定（通常128×128×128或更小）
- **重叠**: 训练时使用重叠补丁增加数据多样性

---

## 推理过程

### 推理流程

#### 1. 预处理

```python
输入: 原始MRI图像 [任意尺寸，任意分辨率]
    ↓
重采样到1×1×1mm各向同性
    ↓
重定向到LPI(-)方向
    ↓
Z-score归一化
    ↓
准备输入: [1, D, H, W] (Step 1) 或 [2, D, H, W] (Step 2)
```

#### 2. 滑动窗口推理

```python
# 使用滑动窗口处理大图像
for patch in sliding_window(image, patch_size, step_size=0.5):
    prediction = model(patch)
    # 使用高斯权重融合重叠区域
    final_prediction += gaussian_weight * prediction
```

**参数**:
- **补丁大小**: 与训练时相同（由plans文件确定）
- **步长**: 0.5（50%重叠）
- **融合方法**: 高斯加权平均

#### 3. 测试时数据增强（TTA）

如果启用TTA（默认启用，除非使用`--disable-tta`）：

```python
# 对输入进行8种变换（旋转90°的4种 × 镜像的2种）
# 但NoMirroring训练器不使用镜像，所以只有4种旋转
predictions = []
for rotation in [0°, 90°, 180°, 270°]:
    rotated_image = rotate(image, rotation)
    pred = model(rotated_image)
    predictions.append(rotate_back(pred, -rotation))

final_prediction = average(predictions)
```

#### 4. 模型集成

如果使用多个fold的模型：

```python
predictions = []
for fold in [0, 1, 2, 3, 4]:
    model = load_model(fold)
    pred = model(image)
    predictions.append(pred)

final_prediction = average(predictions)  # 或投票
```

#### 5. 后处理

```python
# 1. 最大连通分量
prediction = largest_connected_component(prediction)

# 2. 迭代标记
prediction = iterative_labeling(prediction, landmarks)

# 3. 填充椎管
prediction = fill_canal(prediction)

# 4. 转换回原始空间
prediction = transform_to_original_space(prediction, original_image)
```

### 推理性能优化

1. **批处理**: 同时处理多个补丁
2. **多进程预处理**: 并行预处理多个图像
3. **GPU加速**: 使用CUDA加速推理
4. **内存管理**: 使用压缩格式存储中间结果

---

## 后处理算法

### 1. 最大连通分量提取

**目的**: 去除小的噪声区域，保留主要结构

```python
def largest_connected_component(segmentation, label):
    # 对每个类别提取最大连通分量
    binary_mask = (segmentation == label)
    labeled_mask = label_connected_components(binary_mask)
    largest_component = get_largest_component(labeled_mask)
    return largest_component
```

### 2. 迭代标记算法

**目的**: 基于关键标志点，为所有椎骨和椎间盘分配精确标签

#### 算法流程

```
1. 识别关键标志点:
   - C2-C3椎间盘 (label 63)
   - C7-T1椎间盘 (label 71)
   - T12-L1椎间盘 (label 91)
   - L5-S椎间盘 (label 100)
   - C1椎骨 (label 11) - Step 1
   - 骶骨 (label 50) - Step 2

2. 从标志点开始，向上和向下迭代标记:
   - 向上: 从C2-C3标记到C1
   - 向下: 从C2-C3标记到L5-S
   - 使用空间位置和连通性信息

3. 处理特殊情况:
   - 如果C1不可见，使用定位器辅助
   - 如果骶骨不可见，使用定位器辅助
```

#### 伪代码

```python
def iterative_labeling(segmentation, landmarks):
    # 1. 找到关键标志点位置
    c2c3_pos = find_landmark(segmentation, label=63)
    c7t1_pos = find_landmark(segmentation, label=71)
    t12l1_pos = find_landmark(segmentation, label=91)
    l5s_pos = find_landmark(segmentation, label=100)
    
    # 2. 从C2-C3向上标记到C1
    current_disc = c2c3_pos
    disc_label = 63
    while current_disc is not None:
        # 标记当前椎间盘
        segmentation[current_disc] = disc_label
        # 找到下一个椎间盘（向上）
        next_disc = find_next_disc_up(current_disc)
        disc_label -= 1  # C2-C3(63) → C1-C2(62) → ...
        current_disc = next_disc
    
    # 3. 从C2-C3向下标记到L5-S
    current_disc = c2c3_pos
    disc_label = 64  # C3-C4
    while current_disc is not None:
        segmentation[current_disc] = disc_label
        next_disc = find_next_disc_down(current_disc)
        disc_label += 1
        current_disc = next_disc
    
    # 4. 标记椎骨（基于椎间盘位置）
    label_vertebrae(segmentation, disc_positions)
    
    return segmentation
```

### 3. 椎管填充

**目的**: 填充椎管标签，包括所有非脊髓的椎管区域

```python
def fill_canal(segmentation, canal_label=2, cord_label=1):
    # 1. 找到椎管和脊髓的最大连通分量
    canal_mask = get_largest_component(segmentation == canal_label)
    cord_mask = get_largest_component(segmentation == cord_label)
    
    # 2. 在椎管和脊髓之间填充椎管标签
    # 使用形态学操作（膨胀、填充等）
    filled_canal = morphological_fill(canal_mask, cord_mask)
    
    # 3. 更新分割结果
    segmentation[filled_canal] = canal_label
    
    return segmentation
```

### 4. 奇数椎间盘提取（Step 1 → Step 2）

**目的**: 从Step 1的输出中提取奇数位置的椎间盘，作为Step 2的输入

```python
def extract_odd_discs(segmentation):
    odd_disc_labels = [
        63,  # C2-C3 (实际上是偶数，但作为起始点)
        65,  # C4-C5
        67,  # C6-C7
        72,  # T1-T2
        74,  # T3-T4
        # ... 所有奇数位置的椎间盘
    ]
    
    odd_discs_mask = np.zeros_like(segmentation)
    for label in odd_disc_labels:
        odd_discs_mask[segmentation == label] = 1
    
    return odd_discs_mask
```

---

## 模型性能特点

### 优势

1. **鲁棒性**: 对各种MRI对比度、方向和分辨率具有鲁棒性
2. **精确性**: 两阶段设计提高分割和标记精度
3. **自动化**: 完全自动化，无需人工干预
4. **可扩展性**: 基于nnU-Net，易于扩展和改进

### 限制

1. **计算资源**: 需要GPU进行高效推理
2. **内存需求**: 大图像需要大量内存
3. **训练数据**: 需要大量标注数据
4. **特殊病例**: 对于严重异常或罕见病例可能表现不佳

### 性能指标

（根据论文和项目文档，具体数值需要查看评估结果）

- **Dice系数**: 通常 > 0.9（对于主要结构）
- **Hausdorff距离**: 通常 < 2mm
- **推理时间**: 取决于图像大小和GPU性能

---

## 总结

TotalSpineSeg采用了两阶段nnU-Net架构，结合迭代后处理算法，实现了高精度的脊柱结构自动分割和标记。模型设计充分考虑了医学图像的特点和脊柱解剖结构的复杂性，通过关键标志点引导的迭代算法，实现了精确的实例分割。

### 关键技术点

1. **nnU-Net自配置架构**: 自动适应数据集特性
2. **两阶段设计**: Step 1粗分割 + Step 2精分割
3. **双通道输入**: Step 2利用Step 1的结果作为辅助信息
4. **迭代标记算法**: 基于关键标志点的智能标记
5. **无镜像训练**: 保持解剖结构正确性
6. **滑动窗口推理**: 处理任意大小的输入图像

---

*本文档基于TotalSpineSeg项目代码和配置自动生成，最后更新：2025年*

